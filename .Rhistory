Lamb.mL=beta.0+beta.1f*L.f+beta.1m*(k-1)+beta.2*L.f*(k-1)
for (j in 1:J){
mu.ij.mL[,j]=b.0m[j]+b.1m[j]*(k-1)+xlambda.m
}
mu.ij.mL1=mu.ij.mL-mean(mu.ij.mL)
part1.m=(exp(Lamb.mL)/(1+exp(Lamb.mL)))^Y*(1/(1+exp(Lamb.mL)))^(1-Y)
temp.m=(exp(eta.0m+eta.1m*mu.ij.mL1)/(1+exp(eta.0m+eta.1m*mu.ij.mL1)))^U.m*(1/(1+exp(eta.0m+eta.1m*mu.ij.mL1)))^(1-U.m)*
(dlnorm(V.m,meanlog=mu.ij.mL,sdlog=sqrt(tau2.m)))^U.m
part2.m=apply(temp.m,1,prod,na.rm=TRUE)
pr.latent.m[,k]=pi.m[k]*part1.m*part2.m
}
pr.latent.f=pr.latent.f/rowSums(pr.latent.f)
pr.latent.m=pr.latent.m/rowSums(pr.latent.m)
for (i in 1:I){
L.f[i]=sample(0:(K-1),1,replace=TRUE,prob=pr.latent.f[i,])
L.m[i]=sample(0:(K-1),1,replace=TRUE,prob=pr.latent.m[i,])
}
############################
#### update random effect b
############################
for (j in 1:J){
if (gt>100){
cov.r=cov(cbind(b.0f_out[1:(gt-1),j],b.1f_out[1:(gt-1),j],b.0m_out[1:(gt-1),j],b.1m_out[1:(gt-1),j]))
}
if (gt>1 & ((gt-1)%%100==0)){
ar.r=sum(diff(b.0f_out[(gt-100):(gt-1),j])!=0)/99
if (ar.r<0.44){s.r=s.r/sqrt(2)}
else if (ar.r>0.44){s.r=s.r*sqrt(2)}
}
u.r=runif(1)
b.star=rmvnorm(1,c(b.0f[j],b.1f[j],b.0m[j],b.1m[j]),s.r*cov.r+s.r*eps*diag(4))
b.0f.star=b.star[1]
b.1f.star=b.star[2]
b.0m.star=b.star[3]
b.1m.star=b.star[4]
R.r=MH_b(U.f[,j],U.m[,j],V.f[,j],V.m[,j],b.0f.star,b.1f.star,b.0m.star,b.1m.star,b.0f[j],b.1f[j],b.0m[j],b.1m[j])
if (u.r<=R.r){b.0f[j]=b.0f.star;b.1f[j]=b.1f.star;b.0m[j]=b.0m.star;b.1m[j]=b.1m.star}
}
random.b=cbind(b.0f,b.1f,b.0m,b.1m)
###################################
#### update mu.ij.f and mu.ij.m
###################################
for (j in 1:J){
mu.ij.f[,j]=b.0f[j]+b.1f[j]*L.f+xlambda.f
mu.ij.m[,j]=b.0m[j]+b.1m[j]*L.m+xlambda.m
}
mu.ij.f1=mu.ij.f-mean(mu.ij.f)
mu.ij.m1=mu.ij.m-mean(mu.ij.m)
########################################
#### calculate 1st term of DIC
########################################
Lamb=beta.0+beta.1f*L.f+beta.1m*L.m+beta.2*L.f*L.m
pt1=sum(Y*log((exp(Lamb)/(1+exp(Lamb))))-(1-Y)*log(1+exp(Lamb)))
pt2=sum(log(pi.f[(L.f+1)])+log(pi.m[(L.m+1)]))
pt3=sum(U.f*log(exp(eta.0f+eta.1f*mu.ij.f1)/(1+exp(eta.0f+eta.1f*mu.ij.f1)))-(1-U.f)*log(1+exp(eta.0f+eta.1f*mu.ij.f1))+
U.m*log(exp(eta.0m+eta.1m*mu.ij.m1)/(1+exp(eta.0m+eta.1m*mu.ij.m1)))-(1-U.m)*log(1+exp(eta.0m+eta.1m*mu.ij.m1)),na.rm=TRUE)
pt4=sum(log(dlnorm(V.f,meanlog=mu.ij.f,sdlog=sqrt(tau2.f))),na.rm=TRUE)+
sum(log(dlnorm(V.m,meanlog=mu.ij.m,sdlog=sqrt(tau2.m))),na.rm=TRUE)
ptt=rep(0,J)
for (j in 1:J){
ptt[j]=log(dmvnorm(c(b.0f[j],b.1f[j],b.0m[j],b.1m[j]),alpha,Sigma.b))
}
pt5=sum(ptt)
loglike[gt]=pt1+pt2+pt3+pt4+pt5
#####################
## make output files
#####################
pi.f_out[gt,]=pi.f
pi.m_out[gt,]=pi.m
beta.0_out[gt]=beta.0
beta.1f_out[gt]=beta.1f
beta.1m_out[gt]=beta.1m
beta.2_out[gt]=beta.2
alpha.0f_out[gt]=alpha.0f
alpha.1f_out[gt]=alpha.1f
alpha.0m_out[gt]=alpha.0m
alpha.1m_out[gt]=alpha.1m
eta.0f_out[gt]=eta.0f
eta.1f_out[gt]=eta.1f
eta.0m_out[gt]=eta.0m
eta.1m_out[gt]=eta.1m
b.0f_out[gt,]=b.0f
b.1f_out[gt,]=b.1f
b.0m_out[gt,]=b.0m
b.1m_out[gt,]=b.1m
Sigma.b_out[,,gt]=Sigma.b
sig.11_out[gt]=sig.11
sig.12_out[gt]=sig.12
sig.13_out[gt]=sig.13
sig.14_out[gt]=sig.14
sig.22_out[gt]=sig.22
sig.23_out[gt]=sig.23
sig.24_out[gt]=sig.24
sig.33_out[gt]=sig.33
sig.34_out[gt]=sig.34
sig.44_out[gt]=sig.44
tau2.f_out[gt]=tau2.f
tau2.m_out[gt]=tau2.m
lambda.f_out[gt,]=lambda.f
lambda.m_out[gt,]=lambda.m
for (k in 1:K){
L.f_out[gt,k]=sum(L.f==(k-1))
L.m_out[gt,k]=sum(L.m==(k-1))
}
}  ###### 1st MCMC Done!
## save data at every 10th iteration for traceplot
for (t in 1:((nsim-nburn)/10)){
pi.f_T[t,]=pi.f_out[(nburn+10*t),]
pi.m_T[t,]=pi.m_out[(nburn+10*t),]
beta.0_T[t]=beta.0_out[(nburn+10*t)]
beta.1f_T[t]=beta.1f_out[(nburn+10*t)]
beta.1m_T[t]=beta.1m_out[(nburn+10*t)]
beta.2_T[t]=beta.2_out[(nburn+10*t)]
alpha.0f_T[t]=alpha.0f_out[(nburn+10*t)]
alpha.1f_T[t]=alpha.1f_out[(nburn+10*t)]
alpha.0m_T[t]=alpha.0m_out[(nburn+10*t)]
alpha.1m_T[t]=alpha.1m_out[(nburn+10*t)]
eta.0f_T[t]=eta.0f_out[(nburn+10*t)]
eta.1f_T[t]=eta.1f_out[(nburn+10*t)]
eta.0m_T[t]=eta.0m_out[(nburn+10*t)]
eta.1m_T[t]=eta.1m_out[(nburn+10*t)]
b.0f_T[t,]=b.0f_out[(nburn+10*t),]
b.1f_T[t,]=b.1f_out[(nburn+10*t),]
b.0m_T[t,]=b.0m_out[(nburn+10*t),]
b.1m_T[t,]=b.1m_out[(nburn+10*t),]
tau2.f_T[t]=tau2.f_out[(nburn+10*t)]
tau2.m_T[t]=tau2.m_out[(nburn+10*t)]
lambda.f_T[t,]=lambda.f_out[(nburn+10*t),]
lambda.m_T[t,]=lambda.m_out[(nburn+10*t),]
sig.11_T[t]=sig.11_out[(nburn+10*t)]
sig.12_T[t]=sig.12_out[(nburn+10*t)]
sig.13_T[t]=sig.13_out[(nburn+10*t)]
sig.14_T[t]=sig.14_out[(nburn+10*t)]
sig.22_T[t]=sig.22_out[(nburn+10*t)]
sig.23_T[t]=sig.23_out[(nburn+10*t)]
sig.24_T[t]=sig.24_out[(nburn+10*t)]
sig.33_T[t]=sig.33_out[(nburn+10*t)]
sig.34_T[t]=sig.34_out[(nburn+10*t)]
sig.44_T[t]=sig.44_out[(nburn+10*t)]
L.f_T[t,]=L.f_out[(nburn+10*t),]
L.m_T[t,]=L.m_out[(nburn+10*t),]
}
## calculate posterior estimates
beta.0.est=mean(beta.0_out[(nburn+1):nsim])
beta.1f.est=mean(beta.1f_out[(nburn+1):nsim])
beta.1m.est=mean(beta.1m_out[(nburn+1):nsim])
beta.2.est=mean(beta.2_out[(nburn+1):nsim])
beta.0.ci=quantile(beta.0_out[(nburn+1):nsim],probs=c(0.025,0.975))
beta.1f.ci=quantile(beta.1f_out[(nburn+1):nsim],probs=c(0.025,0.975))
beta.1m.ci=quantile(beta.1m_out[(nburn+1):nsim],probs=c(0.025,0.975))
beta.2.ci=quantile(beta.2_out[(nburn+1):nsim],probs=c(0.025,0.975))
alpha.0f.est=mean(alpha.0f_out[(nburn+1):nsim])
alpha.1f.est=mean(alpha.1f_out[(nburn+1):nsim])
alpha.0m.est=mean(alpha.0m_out[(nburn+1):nsim])
alpha.1m.est=mean(alpha.1m_out[(nburn+1):nsim])
alpha.est=c(alpha.0f.est,alpha.1f.est,alpha.0m.est,alpha.1m.est)
alpha.0f.ci=quantile(alpha.0f_out[(nburn+1):nsim],probs=c(0.025,0.975))
alpha.1f.ci=quantile(alpha.1f_out[(nburn+1):nsim],probs=c(0.025,0.975))
alpha.0m.ci=quantile(alpha.0m_out[(nburn+1):nsim],probs=c(0.025,0.975))
alpha.1m.ci=quantile(alpha.1m_out[(nburn+1):nsim],probs=c(0.025,0.975))
eta.0f.est=mean(eta.0f_out[(nburn+1):nsim])
eta.1f.est=mean(eta.1f_out[(nburn+1):nsim])
eta.0m.est=mean(eta.0m_out[(nburn+1):nsim])
eta.1m.est=mean(eta.1m_out[(nburn+1):nsim])
eta.0f.ci=quantile(eta.0f_out[(nburn+1):nsim],probs=c(0.025,0.975))
eta.1f.ci=quantile(eta.1f_out[(nburn+1):nsim],probs=c(0.025,0.975))
eta.0m.ci=quantile(eta.0m_out[(nburn+1):nsim],probs=c(0.025,0.975))
eta.1m.ci=quantile(eta.1m_out[(nburn+1):nsim],probs=c(0.025,0.975))
b.0f.est=colMeans(b.0f_out[(nburn+1):nsim,])
b.1f.est=colMeans(b.1f_out[(nburn+1):nsim,])
b.0m.est=colMeans(b.0m_out[(nburn+1):nsim,])
b.1m.est=colMeans(b.1m_out[(nburn+1):nsim,])
Sigma.b.est=rowMeans(Sigma.b_out[,,(nburn+1):nsim],dims=2)
pi.f.est=colMeans(pi.f_out[(nburn+1):nsim,])
pi.m.est=colMeans(pi.m_out[(nburn+1):nsim,])
tau2.f.est=mean(tau2.f_out[(nburn+1):nsim])
tau2.m.est=mean(tau2.m_out[(nburn+1):nsim])
tau2.f.ci=quantile(tau2.f_out[(nburn+1):nsim],probs=c(0.025,0.975))
tau2.m.ci=quantile(tau2.m_out[(nburn+1):nsim],probs=c(0.025,0.975))
lambda.f.est=colMeans(lambda.f_out[(nburn+1):nsim,])
lambda.m.est=colMeans(lambda.m_out[(nburn+1):nsim,])
lambda.f.ci=apply(lambda.f_out[(nburn+1):nsim,],2,quantile,probs=c(0.025,0.975))
lambda.m.ci=apply(lambda.m_out[(nburn+1):nsim,],2,quantile,probs=c(0.025,0.975))
xlambda.f.est=covariate_f%*%lambda.f.est
xlambda.m.est=covariate_m%*%lambda.m.est
sig.11.est=mean(sig.11_out[(nburn+1):nsim])
sig.12.est=mean(sig.12_out[(nburn+1):nsim])
sig.13.est=mean(sig.13_out[(nburn+1):nsim])
sig.14.est=mean(sig.14_out[(nburn+1):nsim])
sig.22.est=mean(sig.22_out[(nburn+1):nsim])
sig.23.est=mean(sig.23_out[(nburn+1):nsim])
sig.24.est=mean(sig.24_out[(nburn+1):nsim])
sig.33.est=mean(sig.33_out[(nburn+1):nsim])
sig.34.est=mean(sig.34_out[(nburn+1):nsim])
sig.44.est=mean(sig.44_out[(nburn+1):nsim])
sig.11.ci=quantile(sig.11_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.12.ci=quantile(sig.12_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.13.ci=quantile(sig.13_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.14.ci=quantile(sig.14_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.22.ci=quantile(sig.22_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.23.ci=quantile(sig.23_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.24.ci=quantile(sig.24_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.33.ci=quantile(sig.33_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.34.ci=quantile(sig.34_out[(nburn+1):nsim],probs=c(0.025,0.975))
sig.44.ci=quantile(sig.44_out[(nburn+1):nsim],probs=c(0.025,0.975))
##########################################
################ 2nd MCMC ################
##########################################
for (gt in 1:nsim){
#########################
#### update latent class
#########################
## update latent class
mu.ij.fL.est=matrix(1,I,J)
mu.ij.mL.est=matrix(1,I,J)
pr.latent.f=matrix(0,I,K)
pr.latent.m=matrix(0,I,K)
for (k in 1:K){
### for female
Lamb.fL.est=beta.0.est+beta.1f.est*(k-1)+beta.1m.est*L.m+beta.2.est*(k-1)*L.m
for (j in 1:J){
mu.ij.fL.est[,j]=b.0f[j]+b.1f[j]*(k-1)+xlambda.f.est
}
mu.ij.fL1.est=mu.ij.fL.est-mean(mu.ij.fL.est)
part1.f=(exp(Lamb.fL.est)/(1+exp(Lamb.fL.est)))^Y*(1/(1+exp(Lamb.fL.est)))^(1-Y)
temp.f=(exp(eta.0f.est+eta.1f.est*mu.ij.fL1.est)/(1+exp(eta.0f.est+eta.1f.est*mu.ij.fL1.est)))^U.f*(1/(1+exp(eta.0f.est+eta.1f.est*mu.ij.fL1.est)))^(1-U.f)*
(dlnorm(V.f,meanlog=mu.ij.fL.est,sdlog=sqrt(tau2.f.est)))^U.f
part2.f=apply(temp.f,1,prod,na.rm=TRUE)
pr.latent.f[,k]=pi.f.est[k]*part1.f*part2.f
### for male
Lamb.mL.est=beta.0.est+beta.1f.est*L.f+beta.1m.est*(k-1)+beta.2.est*L.f*(k-1)
for (j in 1:J){
mu.ij.mL.est[,j]=b.0m[j]+b.1m[j]*(k-1)+xlambda.m.est
}
mu.ij.mL1.est=mu.ij.mL.est-mean(mu.ij.mL.est)
part1.m=(exp(Lamb.mL.est)/(1+exp(Lamb.mL.est)))^Y*(1/(1+exp(Lamb.mL.est)))^(1-Y)
temp.m=(exp(eta.0m.est+eta.1m.est*mu.ij.mL1.est)/(1+exp(eta.0m.est+eta.1m.est*mu.ij.mL1.est)))^U.m*(1/(1+exp(eta.0m.est+eta.1m.est*mu.ij.mL1.est)))^(1-U.m)*
(dlnorm(V.m,meanlog=mu.ij.mL.est,sdlog=sqrt(tau2.m.est)))^U.m
part2.m=apply(temp.m,1,prod,na.rm=TRUE)
pr.latent.m[,k]=pi.m.est[k]*part1.m*part2.m
}
pr.latent.f=pr.latent.f/rowSums(pr.latent.f)
pr.latent.m=pr.latent.m/rowSums(pr.latent.m)
for (i in 1:I){
L.f[i]=sample(0:(K-1),1,replace=TRUE,prob=pr.latent.f[i,])
L.m[i]=sample(0:(K-1),1,replace=TRUE,prob=pr.latent.m[i,])
}
############################
#### update random effect b
############################
for (j in 1:J){
if (gt>100){
cov.r=cov(cbind(b.0f_out[1:(gt-1),j],b.1f_out[1:(gt-1),j],b.0m_out[1:(gt-1),j],b.1m_out[1:(gt-1),j]))
}
if (gt>1 & ((gt-1)%%100==0)){
ar.r=sum(diff(b.0f_out[(gt-100):(gt-1),j])!=0)/99
if (ar.r<0.44){s.r=s.r/sqrt(2)}
else if (ar.r>0.44){s.r=s.r*sqrt(2)}
}
u.r=runif(1)
b.star=rmvnorm(1,c(b.0f[j],b.1f[j],b.0m[j],b.1m[j]),s.r*cov.r+s.r*eps*diag(4))
b.0f.star=b.star[1]
b.1f.star=b.star[2]
b.0m.star=b.star[3]
b.1m.star=b.star[4]
R.r=MH_b.est(U.f[,j],U.m[,j],V.f[,j],V.m[,j],b.0f.star,b.1f.star,b.0m.star,b.1m.star,b.0f[j],b.1f[j],b.0m[j],b.1m[j])
if (u.r<=R.r){b.0f[j]=b.0f.star;b.1f[j]=b.1f.star;b.0m[j]=b.0m.star;b.1m[j]=b.1m.star}
}
random.b=cbind(b.0f,b.1f,b.0m,b.1m)
###################################
#### update mu.ij.f and mu.ij.m
###################################
for (j in 1:J){
mu.ij.f[,j]=b.0f[j]+b.1f[j]*L.f+xlambda.f.est
mu.ij.m[,j]=b.0m[j]+b.1m[j]*L.m+xlambda.m.est
}
mu.ij.f1=mu.ij.f-mean(mu.ij.f)
mu.ij.m1=mu.ij.m-mean(mu.ij.m)
########################################
#### calculate 2nd term of DIC
########################################
Lamb.est=beta.0.est+beta.1f.est*L.f+beta.1m.est*L.m+beta.2.est*L.f*L.m
pt1=sum(Y*log((exp(Lamb.est)/(1+exp(Lamb.est))))-(1-Y)*log(1+exp(Lamb.est)))
pt2=sum(log(pi.f.est[(L.f+1)])+log(pi.m.est[(L.m+1)]))
pt3=sum(U.f*log(exp(eta.0f.est+eta.1f.est*mu.ij.f1)/(1+exp(eta.0f.est+eta.1f.est*mu.ij.f1)))-(1-U.f)*log(1+exp(eta.0f.est+eta.1f.est*mu.ij.f1))+
U.m*log(exp(eta.0m.est+eta.1m.est*mu.ij.m1)/(1+exp(eta.0m.est+eta.1m.est*mu.ij.m1)))-(1-U.m)*log(1+exp(eta.0m.est+eta.1m.est*mu.ij.m1)),na.rm=TRUE)
pt4=sum(log(dlnorm(V.f,meanlog=mu.ij.f,sdlog=sqrt(tau2.f.est))),na.rm=TRUE)+
sum(log(dlnorm(V.m,meanlog=mu.ij.m,sdlog=sqrt(tau2.m.est))),na.rm=TRUE)
ptt=rep(0,J)
for (j in 1:J){
ptt[j]=log(dmvnorm(c(b.0f[j],b.1f[j],b.0m[j],b.1m[j]),alpha.est,Sigma.b.est))
}
pt5=sum(ptt)
loglike.est[gt]=pt1+pt2+pt3+pt4+pt5
}  ###### 2nd MCMC Done!
## calculate DIC
dev1=-2*mean(loglike[(nburn+1):nsim])
dev2=-2*mean(loglike.est[(nburn+1):nsim])
pD=dev1-dev2
DIC=dev1+pD
proc.time()-ptm
View(try1)
try1$OD
try1$PD
DIC
devtools::check()
?var
#  save(mydata, file="data/mydata.RData")
load("N:/DIPHRData/WeiminZhang/R_Packages/cb_latent_risk_model/biom12972-sup-0003-supprcode-s1/sampledata.rda")
dim(X.f)
dim(covariate_m)
dim(covariate_m)[2]
library(devtools)
library(roxygen2)
library(testthat)
#Step 5: Install!   Now it is as simple as installing the package! You need to run this from the
#parent working directory that contains the cats folder.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
#library(cblatriskmodel)
#?joint_latent_class_Model
library(lchemix)
?JLchemix
#setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\cblatriskmodel")
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\lchemix")
document()
library(devtools)
library(roxygen2)
library(testthat)
#setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\cblatriskmodel")
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\lchemix")
document()
#step 7: Re-Install!You can use devtools::build(binary = TRUE) to make a binary package.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
#need restart
library(lchemix)
?JLchemix
library(MCMCpack)
library(mvtnorm)
data(sampledata)
try1 <-lchemix:::JLchemix(Yvariable= sampledata[,1], X.f_mat = sampledata[,2:37],
X.m_mat = sampledata[,38:73], covariate_f_mat = sampledata[,74:78],
covariate_m_mat = sampledata[,79:83])
try1<-sampledata[,79:83]
dim(try1)
dim(try1)[2]
library(devtools)
library(roxygen2)
library(testthat)
#step 7: Re-Install!You can use devtools::build(binary = TRUE) to make a binary package.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
#library(cblatriskmodel)
#?joint_latent_class_Model
library(lchemix)
?JLchemix
JLchemix()
library(MCMCpack)
library(mvtnorm)
data(sampledata)
try1 <-lchemix:::JLchemix(Yvariable= sampledata[,1], X.f_mat = sampledata[,2:37],
X.m_mat = sampledata[,38:73], covariate_f_mat = sampledata[,74:78],
covariate_m_mat = sampledata[,79:83])
View(try1)
#library(cblatriskmodel)
#?joint_latent_class_Model
library(lchemix)
library(devtools)
library(roxygen2)
library(testthat)
#An important part of the package development process is R CMD check. R CMD check automatically
#checks your code for common problems. It’s essential if you’re planning on submitting to CRAN,
#but it’s useful even if you’re not because it automatically detects many common problems that
#you’d otherwise discover the hard way.
devtools::check()
#Step 3: Add documentation
#This always seemed like the most intimidating step to me. I'm here to tell you - it's super quick.
#The package roxygen2 that makes everything amazing and simple. The way it works is that you add special
#comments to the beginning of each function, that will later be compiled into the correct format for packagedocumentation.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\dpmROCsurface")
document()
#step 7: Re-Install!You can use devtools::build(binary = TRUE) to make a binary package.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
library(devtools)
library(roxygen2)
library(testthat)
#An important part of the package development process is R CMD check. R CMD check automatically
#checks your code for common problems. It’s essential if you’re planning on submitting to CRAN,
#but it’s useful even if you’re not because it automatically detects many common problems that
#you’d otherwise discover the hard way.
devtools::check()
#need restart
library(lchemix)
?JLchemix
?dlnorm
#setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\cblatriskmodel")
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\lchemix")
document()
#step 7: Re-Install!You can use devtools::build(binary = TRUE) to make a binary package.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
library(devtools)
library(roxygen2)
library(testthat)
#An important part of the package development process is R CMD check. R CMD check automatically
#checks your code for common problems. It’s essential if you’re planning on submitting to CRAN,
#but it’s useful even if you’re not because it automatically detects many common problems that
#you’d otherwise discover the hard way.
devtools::check()
library(devtools)
library(roxygen2)
library(testthat)
#setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\cblatriskmodel")
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\lchemix")
document()
#step 7: Re-Install!You can use devtools::build(binary = TRUE) to make a binary package.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
#Getting started with R package
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
library(devtools)
library(roxygen2)
library(devtools)
library(roxygen2)
library(roxygen2)
library(testthat)
#step 7: Re-Install!You can use devtools::build(binary = TRUE) to make a binary package.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
?JLchemix
#need restart
library(lchemix)
?JLchemix
library(dpmROCsurface)
?ROC_Surface
library(devtools)
library(roxygen2)
library(testthat)
#You’re now ready to submit your package to CRAN. The easiest way to do this is to run devtools::release(). This:
devtools::release()
devtools::release()
spell_check()
devtools::spell_check()
devtools::spell_check(lchemix)
?devtools::spell_check()
devtools::spell_check(pkg = "lchemix")
devtools::spell_check(pkg = "")
devtools::spell_check(pkg = ".")
devtools::spell_check(pkg = "C:\Users\zhangw16\Documents\R\R_package\lchemix")
devtools::spell_check(pkg = "C:\\Users\zhangw16\Documents\R\R_package\lchemix")
devtools::spell_check(pkg = "C:\\Users\\zhangw16\\Documents\\R\\R_package\\lchemix")
devtools::release()
check_rhub()
#setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\cblatriskmodel")
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\lchemix")
document()
#Step 5: Install!   Now it is as simple as installing the package! You need to run this from the
#parent working directory that contains the cats folder.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
library(devtools)
library(roxygen2)
library(testthat)
#An important part of the package development process is R CMD check. R CMD check automatically
#checks your code for common problems. It is essential if you are planning on submitting to CRAN,
#but it is useful even if you are not because it automatically detects many common problems that
#you'd otherwise discover the hard way.
devtools::check()
#You’re now ready to submit your package to CRAN. The easiest way to do this is to run devtools::release(). This:
devtools::release()
check_rhub()
#library(cblatriskmodel)
#?joint_latent_class_Model
library(lchemix)
?JLchemix
library(devtools)
library(roxygen2)
library(testthat)
#An important part of the package development process is R CMD check. R CMD check automatically
#checks your code for common problems. It is essential if you are planning on submitting to CRAN,
#but it is useful even if you are not because it automatically detects many common problems that
#you'd otherwise discover the hard way.
devtools::check()
?qpdf
library(qpdf)
library(devtools)
library(roxygen2)
library(testthat)
library(qpdf)
#setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\cblatriskmodel")
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package\\lchemix")
document()
#step 7: Re-Install!You can use devtools::build(binary = TRUE) to make a binary package.
setwd("C:\\Users\\zhangw16\\Documents\\R\\R_package")
#install("cblatriskmodel")
install("lchemix")
#An important part of the package development process is R CMD check. R CMD check automatically
#checks your code for common problems. It is essential if you are planning on submitting to CRAN,
#but it is useful even if you are not because it automatically detects many common problems that
#you'd otherwise discover the hard way.
devtools::check()
